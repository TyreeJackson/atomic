!function()
{"use strict";root.define("atomic.interactiveTutorial.appProxy", function tutorialProtoProxy(localStorage, json)
{
    var examplesKey = "atomic.interactive-tutorials.data.examples";
    function installData(key, data)
    {
        localStorage.setItem(key, json.stringify(data));
    }
    function getData(key, installer)
    {
        if (localStorage.getItem(key) == null)  installData(key, installer());
        return json.parse(localStorage.getItem(key));
    }
    var methods =
    {
        launch:
        function(callback)
        {
            var examples    = getData(examplesKey, getDefaultExamples);
            callback
            ({
                data:
                {
                    examples:   examples
                }
            });
        },
        importExample:
        function(example, callback)
        {
            var exampleSet  = getData(examplesKey, getDefaultExamples);
            exampleSet.examples.push(example);
            installData(examplesKey, exampleSet);
            this.launch(callback);
        },
        saveExamples:
        function(examples, callback)
        {
            installData(examplesKey, examples);
            this.launch(callback);
        },
        resetExamples:
        function(callback)
        {
            installData(examplesKey, getDefaultExamples());
            this.launch(callback);
        }
    };

    function getDefaultExamples()
    {
        var data =
        {
            active:                 "Introduction",
            activeLesson:           0,
            viewEngineModel:        false,
            displayEditors:         true,
            displayAuthorEditors:   false,
            livePreview:            true,
            editorTheme:            "ace/theme/crimson_editor",
            examples:
            [
                {
                    name:       "--Select a tutorial--",
                    example:
                    {
                        placeholder: true,
                    }
                },
                {
                    name:       "Introduction",
                    example:    {"lessons":[{"instructions":"# Welcome!\n\nIn this first tutorial we'll explore the basics of building a user interface with the Model-View-ViewAdapter pattern using AtomicJS.\n\nYou'll see how using this pattern the view is kept unencumbered from any directives or bindings needed to make the user interface work.  Rather the all directives and bindings are defined in the view adapter using a common sense view adapter definition structure.  You'll see how model definitions are kept separate from the view adapter, how the view adapter can bind into the model using observers, and how everything the view remains synchonized with the model by way of the observers dependency tracking.\n\n## Using bindings in the view adapter\n\nIn the bottom-right corner, you've got a view adapter that defines what functional elements should appear in the view.  There is also a model defined containing data about a person.  In the top-right corner, you've got a view that's supposed to display the person data.  Right now it just displays \"_todo_\", so let's fix that.  \n\nModify the two **&lt;strong&gt;** elements in the view, adding id attributes that will connect them to the view adapter.\n\n<pre>\n&lt;p&gt;First Name: &lt;strong <span style=\"background-color: yellow;\">id=\"firstName\"</span>&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Last Name: &lt;strong <span style=\"background-color: yellow;\">id=\"lastName\"</span>&gt;&lt;/strong&gt;&lt;/p&gt;\n</pre>\n\nNow we also need to change the view adapter to bind to the observer.  Modify the two view adapter controls to bind to the model by adding **bind** properties.\n\n<pre>\n{\n    firstName:  {<span style=\"background-color: yellow;\"> bind: \"firstName\" </span>},\n    lastName:   {<span style=\"background-color: yellow;\"> bind: \"lastName\" </span>}\n}\n</pre>\n\nView elements can be connected to view adapter controls via any css selector, however id attributes are used by default.  The name of the view adapter control is used in a \"#\" css selector when no specific selector has been specified to find an element to connect to.  If no element is found an appropriate element is created based on whether or not type has been specified on the view adapter control.  _(We'll explore this more in the next lesson)_\n\nThe **bind** property of view adapter controls are how AtomicJS let's you associate model properties with properties of those controls.  You'll see more on what other properties can be bound in later lessons and tutorials.\n\n## Running the code\n\nTo run your updated application, either click Run in the nav bar at the top of the screen or check the Live Preview checkbox in the side bar to keep the preview up to date with the markup and code.\n\nAfter you have updated the markup and code appropriately, the UI should display the person's name.\n\nIf everything is working fine, click _Continue_ below.\n\n**Having trouble?** If at any time you find it unclear how to proceed, and your code is working correctly, feel free to click the \"Help - it's not working!\" button below.  This will replace your code and markup with a working copy.\n\n\n\n\n\n\n_<sup>Disclaimer: If you are familiar with the Knockout JS interactive tutorials, some of the text in these lessons may seem plagerized.  This is intentional, as these tutorials are designed to guide users of these types of systems to become familiar with another model based on the principles of unobtrusive javascript.  These tutorials and related playgrounds and other materials were built as proofs of concept that there is another way to build the same types of applications that does not rely on mixing markup and directives in the same structures.</sup>_\n","javascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:  { },\n        lastName:   { }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","html":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong>todo</strong></p>\n<p>Last name: <strong>todo</strong></p>","targetJavascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:  { bind: \"firstName\" },\n        lastName:   { bind: \"lastName\" }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","targetHTML":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>"},{"instructions":"# Welcome revisited (the no HTML alternative)\n\nIn the previous lesson, you saw the typical way that someone might build a UI that displays a person's first and last name.  There is alternative way to produce the same output without using any HTML at all.  By using _type_ properties on your view adapter controls, you can tell AtomicJS what kinds of controls you want in your view without actually having to specify them.  While this results in UI with minimal formatting, it does allow for rapid creation of user interfaces with a focus solely on JavaScript.  Even better, you can always add the markup later and AtomicJS will connect the view adapter controls to their corresponding elements in the view at that time.\n\nTake a look at the JavaScript in the bottom-right to see another way to build the user interface.  Notice that once again it just displays _\"todo\"_, so let's fix that again.\n\nModify the two **name** controls  in the view adapter adding **bind** properties:\n\n<pre>\n{\n    firstNameField:\n    {\n        controls:\n        {\n            firstNameLabel: { type: \"label\",    value: \"First Name:\" },\n            firstName:      { type: \"readonly\", <span style=\"background-color: yellow;\">bind: \"firstName\" </span> }\n        }\n    },\n    lastNameField:\n    {\n        controls:\n        {\n            lastNameLabel:  { type: \"label\",    value: \"Last Name:\" },\n            lastName:       { type: \"readonly\", <span style=\"background-color: yellow;\">bind: \"lastName\" </span> }\n        }\n    }\n}\n</pre>\n\nAfter you've got the code working move to the next lesson to see how we can add the markup in and control the formatting.\n","javascript":"root.atomic.launch\n(\n    {\n        firstNameField:\n        {\n            controls:\n            {\n                firstNameLabel: { type: \"label\",    value: \"First Name:\" },\n                firstName:      { type: \"readonly\", value: \"todo\" }\n            }\n        },\n        lastNameField:\n        {\n            controls:\n            {\n                lastNameLabel:  { type: \"label\",    value: \"Last Name:\" },\n                lastName:       { type: \"readonly\", value: \"todo\" }\n            }\n        }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n)","html":"","targetJavascript":"root.atomic.launch\n(\n    {\n        firstNameField:\n        {\n            controls:\n            {\n                firstNameLabel: { type: \"label\",    value: \"First Name:\" },\n                firstName:      { type: \"readonly\", bind: \"firstName\" }\n            }\n        },\n        lastNameField:\n        {\n            controls:\n            {\n                lastNameLabel:  { type: \"label\",    value: \"Last Name:\" },\n                lastName:       { type: \"readonly\", bind: \"lastName\" }\n            }\n        }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n)","targetHTML":""},{"instructions":"# Welcome revisited (defining the view after the view adapter)\n\nIn the previous lesson we saw how we can define view adapter controls without actually defining any view markup.  In this lesson we'll continue from the last lesson by adding custom markup to apply specific formatting to make the second example look more like the first example.\n\n## Adding markup to the view\n\nRemember how earlier we saw that the view elements are matched to the view adapter controls by matching the element's **id** to the **name** of the control by default?  Let's use this approach to add elements to the markup that correspond with the controls then.  Add the following markup to the html editor in the top-right:\n\n<pre>\n<span style=\"background-color: yellow;\">&lt;p id=\"firstNameField\"&gt;&lt;span id=\"firstNameLabel\"&gt;First Name:&lt;/span&gt; &lt;strong id=\"firstName\"&gt;&lt;/strong&gt;&lt;/p&gt;</span>\n<span style=\"background-color: yellow;\">&lt;p id=\"lastNameField\"&gt;&lt;span id=\"lastNameLabel\"&gt;Last Name:&lt;/span&gt; &lt;strong id=\"lastName\"&gt;&lt;/strong&gt;&lt;/p&gt;</span>\n</pre>\n\nNow the output should match the look of the example in the first lesson.  This method of constructing the view adapter before the view is just one way that developers can work with AtomicJS.  Most will probably start with the markup and then move to the view adapter definition, and others might go back and forth between the two methods.  There is no wrong way.  For the rest of the examples in this lesson we will focus on defining both the view and the view adapter definition together as we build more interesting interfaces.\n","javascript":"root.atomic.launch\n(\n    {\n        firstNameField:\n        {\n            controls:\n            {\n                firstNameLabel: { type: \"label\",    value: \"First Name:\" },\n                firstName:      { type: \"readonly\", bind: \"firstName\" }\n            }\n        },\n        lastNameField:\n        {\n            controls:\n            {\n                lastNameLabel:  { type: \"label\",    value: \"Last Name:\" },\n                lastName:       { type: \"readonly\", bind: \"lastName\" }\n            }\n        }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n)","html":"","targetJavascript":"root.atomic.launch\n(\n    {\n        firstNameField:\n        {\n            controls:\n            {\n                firstNameLabel: { type: \"label\",    value: \"First Name:\" },\n                firstName:      { type: \"readonly\", bind: \"firstName\" }\n            }\n        },\n        lastNameField:\n        {\n            controls:\n            {\n                lastNameLabel:  { type: \"label\",    value: \"Last Name:\" },\n                lastName:       { type: \"readonly\", bind: \"lastName\" }\n            }\n        }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n)","targetHTML":"<p id=\"firstNameField\"><span id=\"firstNameLabel\">First Name:</span> <strong id=\"firstName\"></strong></p>\n<p id=\"lastNameField\"><span id=\"lastNameLabel\">Last Name:</span> <strong id=\"lastName\"></strong></p>"},{"instructions":"# Making the data editable\n\nYou're not limited to displaying static data.  In this example we will add **input** controls with **value** bindings to make the data editable.\n\nAdd the following markup to the bottom of your view (leaving the existing markup in place above it):\n\n<pre>\n&lt;p&gt;First Name: &lt;input id=\"firstNameInput\" /&gt;&lt;/p&gt;\n&lt;p&gt;Last Name: &lt;input id=\"lastNameInput\" /&gt;&lt;/p&gt;\n</pre>\n\nNow we also need to add the following controls to the view adapter by changing the definition:\n\n<pre>\n{\n    firstName:      { bind: \"firstName\" },\n    lastName:       { bind: \"lastName\" }<span style=\"background-color: yellow;\">,\n    firstNameInput: { bind: \"firstName\" },\n    lastNameInput:  { bind: \"lastName\" }</span>\n}\n</pre>\n\nAnd noticed, that worked!  The reason for this is that the model specified as the second argument to the ***root.atomic.launch** method has been bound to the view adapter by way of an intermediary...\n\n## Introducing Observers\n\nWhen you edit one of the text boxes, the control sends the update to the observer with the path in the model graph that the control is bound to and the new value.  The observer updates the underlying model data and then notifies any other listeners (including controls) of the change that have previously read the value at that location in the object graph during a bind operation.  These other listeners/controls can then update their bound properties to reflect the change.  The underlying model is a simple POJO that has no support for performing these kinds of operations which is why AtomicJS has observers.\n\n<sup>Point of comparison: Other library/frameworks such as Knockout have a similar concept known as observables.  Observers are different in that they wrap the entire model instead of defining individual properties on a view model that can be bound to.  This means that all properties in the model can be bound to, including properties that do not yet exist!  We'll see an example of this in a future lesson.</sup>","javascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:  { bind: \"firstName\" },\n        lastName:   { bind: \"lastName\" }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","html":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>","targetJavascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:      { bind: \"firstName\" },\n        lastName:       { bind: \"lastName\" },\n        firstNameInput: { bind: \"firstName\" },\n        lastNameInput:  { bind: \"lastName\" }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","targetHTML":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>\n\n<p>First Name: <input id=\"firstNameInput\" /></p>\n<p>Last Name: <input id=\"lastNameInput\" /></p>"},{"instructions":"# Controls with computed values\n\nVery often, you'll want to combine or convert multiple values to make others in various controls.  In this example, we will add a control that displays the _full name_ as a value computed as _first name_ plus a _space_ plus _last name_.\n\nTo handle this Atomic has a concept of **computed bindings** - these are functions defined on the control in place of simple bindings that read one or more model properties via the observer bound to the control.\n\n## Introducing the **.data()** property\n\nAll controls have a _.data_ property that returns the **observer** that has been bound to the view adapter with the root path set to any relative paths in the model graph that parent controls have been bound to _(more on this later)_.  Let's see how this works.\n\nAdd a fullName element and control to your view and view adapters respectively by adding the following markup and changing the code:\n\n<pre>\n&lt;p&gt;Full Name: &lt;strong id=\"fullName\"&gt;&lt;/strong&gt;&lt;/p&gt;\n</pre>\n\n<pre>\n{\n    firstName:      { bind: \"firstName\" },\n    lastName:       { bind: \"lastName\" },\n    firstNameInput: { bind: \"firstName\" },\n    lastNameInput:  { bind: \"lastName\" }<span style=\"background-color: yellow;\">,\n    fullName:       { bind: function(){ return this.data(\"firstName\") + \" \" + this.data(\"lastName\"); } }</span>\n}\n</pre>\n\nIf you look at the updated application now and edit the text boxes, you'll see that all of the controls (including the full name control) stay in sync with the underlying data.\n\n## How does it work?\n\nThings stay in sync because of the observer depdency tracking: the fullName control has a computed function for its **bind** property which computes the full name from the **firstName** and **lastName** which are each bound to input controls.  Changes made to the values of those properties by those input controls are propagated to all of the bound listeners/controls that have read those properties in the object graph via their bound observers.  This operation only notifies those listeners/controls affected by the updates resulting in a minimal set of refreshes to controls needed to bring your UI up-to-date.\n\n","javascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:      { bind: \"firstName\" },\n        lastName:       { bind: \"lastName\" },\n        firstNameInput: { bind: \"firstName\" },\n        lastNameInput:  { bind: \"lastName\" }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","html":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>\n\n<p>First Name: <input id=\"firstNameInput\" /></p>\n<p>Last Name: <input id=\"lastNameInput\" /></p>","targetJavascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:      { bind: \"firstName\" },\n        lastName:       { bind: \"lastName\" },\n        firstNameInput: { bind: \"firstName\" },\n        lastNameInput:  { bind: \"lastName\" },\n        fullName:       { bind: function(){ return this.data(\"firstName\") + \" \" + this.data(\"lastName\"); } }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","targetHTML":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>\n\n<p>First Name: <input id=\"firstNameInput\" /></p>\n<p>Last Name: <input id=\"lastNameInput\" /></p>\n\n<p>Full Name: <strong id=\"fullName\"></strong></p>"},{"instructions":"# Adding more behavior\n\nTo finish this example, let's add one final behavior: a button that makes the \"last name\" value turn upper-case.\n\n## Updating the view/view adapter\n\nFirst add a **button** element to the view and a corresponding control to the view adapter:\n\n<pre>\n&lt;button id=\"capitalizeLastNameButton\"&gt;Go caps&lt;/button&gt;\n</pre>\n\n<pre>\n{\n    firstName:                  { bind: \"firstName\" },\n    lastName:                   { bind: \"lastName\" },\n    firstNameInput:             { bind: \"firstName\" },\n    lastNameInput:              { bind: \"lastName\" },\n    fullName:                   { bind: function(){ return this.data(\"firstName\") + \" \" + this.data(\"lastName\"); } }<span style=\"background-color: yellow;\">,\n    capitalizeLastNameButton:   { onclick: function() { this.data(\"lastName\", this.data(\"lastName\").toUpperCase()); } }</span>\n}\n</pre>\n\nNow if you click on the \"Go caps\" button in the updated application , you'll see all relevant parts of the user interface has been updated to match the changed model.\n","javascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:      { bind: \"firstName\" },\n        lastName:       { bind: \"lastName\" },\n        firstNameInput: { bind: \"firstName\" },\n        lastNameInput:  { bind: \"lastName\" },\n        fullName:       { bind: function(){ return this.data(\"firstName\") + \" \" + this.data(\"lastName\"); } }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","html":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>\n\n<p>First Name: <input id=\"firstNameInput\" /></p>\n<p>Last Name: <input id=\"lastNameInput\" /></p>\n\n<p>Full Name: <strong id=\"fullName\"></strong></p>","targetJavascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:                  { bind: \"firstName\" },\n        lastName:                   { bind: \"lastName\" },\n        firstNameInput:             { bind: \"firstName\" },\n        lastNameInput:              { bind: \"lastName\" },\n        fullName:                   { bind: function(){ return this.data(\"firstName\") + \" \" + this.data(\"lastName\"); } },\n        capitalizeLastNameButton:   { onclick: function() { this.data(\"lastName\", this.data(\"lastName\").toUpperCase()); } }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","targetHTML":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>\n\n<p>First Name: <input id=\"firstNameInput\" /></p>\n<p>Last Name: <input id=\"lastNameInput\" /></p>\n\n<p>Full Name: <strong id=\"fullName\"></strong></p>\n\n<button id=\"capitalizeLastNameButton\">Go caps</button>"},{"instructions":"# Good job!\n\nThese were very basic examples, but they illustrated some of the key points of MVVA\n\n* You've got a clean, object-oriented representation of all of your data (view oriented or otherwise) in the form of an object graph (your model)\n* You've got a clean, object-oriented representation of your view in the form of a view adapter which encapsulates your UI's behaviors and bindings (your view adapter)\n* Additionally, youve got a declarative definition how your view's structure should be formatted and refined (your view)\n* You can implement abitrarily sophisticated behaviors and bindings just by updating the view adapter object.  You don't have to worry about which DOM elements/attributes need to be changed/added/removed - the library can take care of synchronizing things for you.\n\nSubsequent tutorials will take you further including introducing the final letter in the MVVAC acronym _(Controller)_ and other supporting concepts such as isolating remote service calls to **proxy** objects.\n","javascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:                  { bind: \"firstName\" },\n        lastName:                   { bind: \"lastName\" },\n        firstNameInput:             { bind: \"firstName\" },\n        lastNameInput:              { bind: \"lastName\" },\n        fullName:                   { bind: function(){ return this.data(\"firstName\") + \" \" + this.data(\"lastName\"); } },\n        capitalizeLastNameButton:   { onclick: function() { this.data(\"lastName\", this.data(\"lastName\").toUpperCase()); } }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","html":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>\n\n<p>First Name: <input id=\"firstNameInput\" /></p>\n<p>Last Name: <input id=\"lastNameInput\" /></p>\n\n<p>Full Name: <strong id=\"fullName\"></strong></p>\n\n<button id=\"capitalizeLastNameButton\">Go caps</button>","targetJavascript":"root.atomic.launch\n(\n    // This is a simple *view adapter* - JavaScript that defines the structure and behavior of your UI\n    {\n        firstName:                  { bind: \"firstName\" },\n        lastName:                   { bind: \"lastName\" },\n        firstNameInput:             { bind: \"firstName\" },\n        lastNameInput:              { bind: \"lastName\" },\n        fullName:                   { bind: function(){ return this.data(\"firstName\") + \" \" + this.data(\"lastName\"); } },\n        capitalizeLastNameButton:   { onclick: function() { this.data(\"lastName\", this.data(\"lastName\").toUpperCase()); } }\n    },\n    {\n        firstName:  \"Brett\",\n        lastName:   \"Berlington\"\n    }\n);","targetHTML":"<!-- This is a *view* - HTML markup that defines the appearance of your UI overall and nothing more -->\n\n<p>First name: <strong id=\"firstName\"></strong></p>\n<p>Last name: <strong id=\"lastName\"></strong></p>\n\n<p>First Name: <input id=\"firstNameInput\" /></p>\n<p>Last Name: <input id=\"lastNameInput\" /></p>\n\n<p>Full Name: <strong id=\"fullName\"></strong></p>\n\n<button id=\"capitalizeLastNameButton\">Go caps</button>", nohelp: true}]}
                }
            ]
        };
        return data;
    }

    return methods;
});}();